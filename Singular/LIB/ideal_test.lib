//this will be the ideal test thingi

proc compIds(ideal I1, ideal I2)
"
"
{
 int i1,i2,t;
 poly p;
 list R;
 ideal It;
 for (i1 = 1; i1 <= size(I1); i1++)
 {
  p = I1[i1];
  for (i2 = 1; i2 <= size(I2); i2++)
  {
   if (p==I2[i2]) {t = 1; break;}
  }
  if (t == 0) {It[size(It)+1] = p;}
  else {t = 0;}
 }
 R[1] = It;
 kill It; ideal It;
 

 
 for (i2 = 1; i2 <= size(I2); i2++)
 {
  p = I2[i2];
  for (i1 = 1; i1 <= size(I1); i1++)
  {
   if (p==I1[i1]) {t = 1; break;}
  }
  if (t == 0) {It[size(It)+1] = p;}
  else {t = 0;}
 }
 R[2] = It;
 

 return(R);
}

proc lpGbVs(ideal I)
"
"
{
 ideal I1; ideal I2;
 list R;
 I1 = letplaceGBasis(I);
 I2 = system("freegbdvc",I,attrib(basering,"uptodeg"), attrib(basering,"lV"));
 R = compIds(I1,I2);
 return(R);
}

proc itProc(list L)
"
"
{
 int i;
 list R;
 for (i=1; i <= size(L); i++)
 {
  R[size(R)+1] = lpGbVs(L[i]);
 }

 return(R);
}


/*
test:

LIB "freegb.lib";
ring r = 0,(x,y),dp;
def R = makeLetterplaceRing(10);
setring R;
ideal I = x(1)*x(2) + x(1)*y(2),y(1)*x(2);




*/

/*
proc makeLetterplaceIdeal(def base, def lpRing, ideal I, int d)
"USAGE: makeLetterplaceIeal(r, R, I); r the base Ring, the letterplace
ring R was created from. I an ideal in r.
RETURN: a letterplace Ideal in R (corresponding to I)
PURPOSE: Creates an ideal in the letterplace ring R, which corresponds
to the ideal I from r. d should be the number of variables in the base
ring.
"
{
  setring base;
  // get list of variables in letterplac Ring
  list L = ringlist(lpRing)[2];

  int i,j,k,l;
  list Il;
  for (i = 1; i <= size(I); i++)
  {
    Il[i] = list();
    for(j = 1; j <= size(I[i]); j++)
    {
      Il[i][j] = leadexp(I[i][j]);
    }
  }

  setring lpRing;
  ideal II;
  int expK;
  poly m;
  for (i = 1; i <= size(Il); i++)
  {
    II[i] = 0;
    for(j = 1; j <= size(Il[i]); j++)
    {
      Il[i];
      l = 0;
      m = 1;
      for(k = 1; k <= size(Il[i][j]); k++)
      {
        expK = Il[i][j][k];
        while(expK > 0)
        {
          execute("m = m * "+L[l*d+k]);
          expK--;
          l++;
        }
      }
      II[i] = II[i] + m;
    }
  }

  return(II);
}
example
{
  "EXAMPLE:"; echo = 2;
}
*/

proc deHomogLpIdeal(ideal I, int d, int i)
"USAGE: deHomogLpIdeal(I, i); I a Letterplace ideal, d,i Integers
RETURN:Ideal, where some Variables are replace by 1 (see PURPOSE)
PURPOSE: Dehomogenize an Ideal. i should be the index, with 
respect to the ordering of the current active ring, of the Variable 
in the Base ring we want to replace by 1 in the Letterplace ring.
d should be the number of variables in the base ring.
"
{
  i = i % d;
  list L=maxideal(1);
  int j;
  for(j=1; j<=size(L[1]); j=j+1){if(j % d == i) {L[1][j] = 1;}}
  map f=basering,L[1];
  return(simplify(f(I),2));
}
example
{
  "EXAMPLE:"; echo = 2;
  LIB "freegb.lib";
  LIB "ideal_test.lib";
  ring r = 0,(a,x,y),dp;
  def R = makeLetterplaceRing(10);
  setring R;
  ideal I =  x(1)*x(2) + x(1)*y(2),
             x(1)*y(2)*y(3) + x(1)*x(2)*a(3),
             a(1)*x(2) - x(2)*a(1);
  deHomogLpIdeal(I,3,1);
}

proc homogLpIdeal(ideal I, def r, int d, int n, int uptodeg)
"USAGE: homogLpIdeal(I, i); I a Letterplace ideal, d,i Integers
RETURN: homogenized letterplace Ideal 
PURPOSE: Homogenize an Ideal. r should be the letterplace ideal, in
which the polys from I are defined, which contains an additional
variable, which will be used to homogenize the ideal I. d should be the
number of Variables in the base ring r, n the position of the additional
variable in ringlist(r)[2];
"
{

  int i;
  intvec equalWeights;
  for(i = 1; i <= uptodeg*d; i++)
  {
    equalWeights[i] = 1;
  }

  ideal H;
  int j, k, degP; 
  number coeff;
  for(i = 1; i <= size(I); i++)
  {
    H[i] = 0;
    for(j = 1; j <= size(I[i]); j++)
    {
      degP = deg(I[i], equalWeights);
      coeff = leadcoef(I[i][j]);
      intvec vExp = leadexp(I[i][j]);
      for(k = deg(I[i][j]); k < degP; k++)
      {
        vExp[k*d + n] = 1;
      }
      H[i] = H[i] + coeff * monomial(vExp);
      kill vExp;
    }
  }

  return(H);
}
example
{
  "EXAMPLE:"; echo = 2;
}

proc homogLpIdealInverse(ideal I, int d, int n)
"USAGE: homogLpIdealInverse(I, d, n); I a Letterplace ideal, d,n Integers
RETURN: homogenized letterplace Ideal 
PURPOSE: Homogenize an Ideal by inserting an additional placeholder
variable into it. It is assumend, that this variable already is present
and has index n with respect to the ordering of the ring, the
letterplace Ring was created from (see Example).
"
{
  int i;
  int uptodeg = attrib(basering,"uptodeg");
  int lV = attrib(basering,"lV");
  intvec equalWeights;
  for(i = 1; i <= uptodeg*d; i++)
  {
    equalWeights[i] = 1;
  }

  ideal H;
  poly Sij;
  int j, k, degP, degM, shift; 
  number coeff;
  for(i = 1; i <= size(I); i++)
  {
    H[i] = 0;
    degP = deg(I[i], equalWeights);
    for(j = 1; j <= size(I[i]); j++)
    {
      degM = deg(I[i][j], equalWeights);
      coeff = leadcoef(I[i][j]);
      shift = degP - degM;
      Sij = system("stest",I[i][j],shift,uptodeg,lV);
      intvec vExp = leadexp(Sij);
      for(k = 0; k < shift; k++)
      {
        vExp[k*d + n] = 1;
      }
      H[i] = H[i] + coeff * monomial(vExp);
      kill vExp;
    }
  }

  return(H);
}
example
{
  "EXAMPLE:"; echo = 2;
  LIB "freegb.lib";
  LIB "ideal_test.lib";
  ring r = 0,(x,y,a),dp;

  //This will tell us the index of a, which is 3 of course
  ringlist(r)[2];

  def R = makeLetterplaceRing(10);
  setring R;
  ideal I =  x(1)*x(2) + x(1)*y(2),
             x(1)*y(2)*y(3) + x(1)*x(2);
  ideal J = homogLpIdealInverse(I, 3, 3);
}

proc addCommutators(ideal I, int n, int d)
"USAGE: addCommutators(I, d, n, u); I a Letterplace ideal, d,n Integers
RETURN: I union C, where C contains all Commuators x*y - y*x, where x,y
are variables in the current ring, with x having index n in the current
ring
PURPOSE: add the Commutators to i. d should be the number of variables
in the non-commutative ring corresponding to the letterplace ring. Sorry
for the bad description, this ist definitly not my best day.
"
{
  int i, j;
  for(i = 1; i <= d; i++)
  {
    intvec m;
    poly cm;
    if(i == n){ i++; continue; }
    for(j = 1; j <= d; j++)
    {
      if(j == n){ m[j] = 1; }
      else{ m[j] = 0; }
    }
    for(j = 1; j <= d; j++)
    {
      if(j == i){ m[j + d] = 1; }
      else{ m[j + d] = 0; }
    }
    cm = monomial(m);
    kill m;
    intvec m;
    for(j = 1; j <= d; j++)
    {
      if(j == i){ m[j] = 1; }
      else{ m[j] = 0; }
    }
    for(j = 1; j <= d; j++)
    {
      if(j == n){ m[j + d] = 1; }
      else{ m[j + d] = 0; }
    }
    cm = cm - monomial(m);
    I = I,cm;
    kill cm;
    kill m;
  }

  return(I);
}
